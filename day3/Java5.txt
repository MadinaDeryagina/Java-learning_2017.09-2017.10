		Примитивные типы:
	1. Целочисленные типы.
	byte b;
	Если мы хотим считать локальную переменную, напишем System.out.println(b); Компилятор выдаст ошибку о том, что переменная b не проинициализирована.
	Однако если мы выполним static int j; эта переменная будет проинициализирована автоматически и System.out.println(j); ошибки не выдаст, проинициализировано
будет значение 0 соответсвующего типа, для int j = 0, для ссылочного типа j = null и т.п.
	//region Целые
	byte b = 0; 	// 1 byte
	short s = 0;	// 2 byte
	int i = 0;		// 4 byte
	long l =0;		// 8 byte
	//endregion Эти учатски можно сворачивать для более комфортного отображения.
	В каких диапазонах будет byte? от 0 до 255 или от -128 до 127. При выборе этого числа через точку можно узнать максимально и минимальное значение. 
	Пример: Byte.MIN_VALUE Byte.MAX_VALUE
	Все числовые типы имеют модификатор signed = то есть там есть положительная и отрицательная часть.
	По факту разные переменные могут хранить разное количество байт, в зависимости от JDK - это сделано из расчета на повышение производительности, это связано
с разрядностью регистров процессора.

	Литерал - это значение, которое не вынесено куда-то в конфигурации, а прям в исходнике заданное жестко значение.
	Литерал - это какое то значение, которое задано прямо в исходнике. Литералы могут быть целочисленные, строковы, типа массив, типа значения с плавающей точкой.
	Как можно описывать литеральчики?
		Литералы можно задавать в: десятиричной системе, восьмиричной, шестнадцатиричной, двоичной и т.д.
		Для разделения разрядов можно использовать underscode, например byte b = 1_00.
		
	2. Типы с плавающей точкой.
	//region С плавающей точкой
	float f = 0;	// 16 byte, IEEE 754
	double d = 0.0;	// 32 byte
	//endregion
	Как задать значения переменным с плавающей точкой:
	double d = -2e-5 = -2*10^(-5)
	Компилятор мыслит не значениями литералов, он мыслит типами этих литералов, например float f = 0.; такое будет ошибка, т.к. несовпадение типов
	В Java можно использовать явное приведение типов, еще можно использовать к примеру float f = 0.F;
	В системе вычисления типов для Java, для целочисленных литералов, он сразу пытается поместить это в int, если не получается он пытается вывести область, 
в какой тип мы хотим присвоить значение, если у него не получается, он пытается привести его явно. К примеру если мы напишем long l = 1000000000000; - выдаст 
ошибку, несмотря на то, что значение типа long, компилятору тогда надо помочь и указать ему явно long l = 1000000000000L;
	В зависимости от вендора JDK может различаться работа с числами, если мы хотим игнорировать вендорские нововведения, используем ключевое слово strictfp
в main, тогда будет использоваться стандарт IEEE 754, пример:
	public strictfp class PrimitivesDemo {
		public strictfp static void main(String [] args)
		{
			long l = 1000000000000L;
		}
	}
	
	3. Символьные типы данных.
	char c = 100;	// Только это не ASCII, в Java все символы в unicode
	char c = '';	// Так можно задать символ, в Java задание символов делается в одинарных кавычках, строки задаются в двойных.
	Символы можно задать так: char c = '\uAAAA'; Если на клавиатуре нет специального символа(задается в шестнадцатиричной системе)
	Если мы захотим привести unicode к целому типу, то это будет тип int, потому что в unicode нет отрицательного диапазона.
	Есть управляющие последовательности, они регламентируются стандартом, например \t - это табуляция, \b - звуковой сигнал, набор символов достаточно большой
рабочий набор \r, \n, \t

	4. Логические типы данных
	В Java исходя из однозначности, boolean = однозначный тип true или false. Его ни явно ни неявно нельзя привести к другому типу.
	//region Логические типы
	boolean boo = true | false;
	//endregion Логические типы
	К сожалению для
	Вопрос: что выведут следующие вещи?
	a) System.out.println(1/3) 
	b) System.out.println(.1 + .2)
	c) System.out.println(1/0) 
	d) System.out.println(1/0.) 
	Ответ:
	a) 0
	b) 0.30000000000000004
	c) arithmeticException
	d) infinity
	.one+.two