				Примитивные типы(немного забежали вперед и обсудили ссылочные типы).
	В Java 8 приминивных типов.
	Все что делается оператором new, хранится в куче(heap).
	Начнем рисовать то, как устроена память в Java.
	
					JVM Memory
		
	/	|	 |	|	|		- это стеки, единственный способ положить переменную в Heap - это оператор new. В Java нет malloc/calloc  :(
	|	|m2	 |	|	|
-Xss|	|m	 |	|	|	new			 -----------
	|	|main|	| --|->Reference--->|--->Value	|
	\	 ----	|	|				|			|
		  |_____|	|				|	Heap	| <-- Настраивается ключиками -Xms -минимальный размер оперативы -Xmx - максимальный размер
			 |______|				|			|
								 _->|___________|_______
								/		|				|	- это дополнительная память для static-переменных		
								|		|				|
								|		|				|	Perm Space
								--------|				|	Meta Space
										 ---------------
									
									
		Пример:
		
		public class PrimitivesDemo {
			public static void main(String [] args) {
				Cat cat1;
				cat1 = new Cat(0);
			}
		}
		
		class Cat {
			private int id;
			public Cat(int id) {
				this.id - id;
			}
		}
		Оператор new выделяет память в heap под переменную и возвращает ссылку на эту переменную.
		Ссылка - это уникальный идентификатор объекта в heap.
		System.out.println(new Cat(0)) - возвратит нам тип @ и identity hash, например получится demo.Cat@66d3c617
		Если сделать new Cat(0), когда вызовется сборщик мусора, если на него нет ссылок?
		Объект считается муосором, если он прямо или косвенно не достижим из стека программы. Даже если в heap есть объекты, которые имеют ссылки на другие 
объекты в heap, если нет возможности из стека добраться до конечного объекта, он считается мусором.
	new Cat(); - память аллоцируется в heap, но если нет ссылок, когда же он будет удален? Ответ: когда мы удаляем ссылку на объект в heap, мы помещаем 
переменную в heap как мусор, garbageCollector удалит ее тогда, когда она захочет. Если heap переполнится, память в любом случае придется очищать.
В большинстве JVM garbageCollector не будет запускаться по таймеру или по просьбе, он запустится тогда, когда почувствует, что пора чистить память.
В oracle это можно настраивать. Есть несколько алгоритмов сборки мусора.
		На один объект может быть несколько ссылок, мы можем обращаться и изменять объект по любой из ссылок.
		
			Где живут static-переменные?
	class Cat {
		public static int catsCount;
	}
	MetaSpace - это память которая входит в heap, но хранит статик-переменные.
	Через инстанс конечно можно запросить эту переменную, но вообще говоря, со статик-типом мы это можем сделать без экземпляра класса.
	Что по поводу ссылок из PermSpace на объекты в heap - garbageCollector не будет удалять объект в heap, пока живут ссылки в этой памяти.
	С этой памятью мы можем делать deploy и undeploy классов(загружать и выгружать классы). Класс с одинаковым именем и разными версиями можно создать 
параллельно за счет динамической загрузки классов. За счет этого достигается Uptime, чтобы не останавливать полнотью приложения.
	Если во время выгрузки класса, мы пытаемся создать экзепляр этого класса, произойдет исключительная ситуация, которую придется обработать.
	
	JIT - делает профилировку. JVM с помощью JIT делает профилировку, вычисляет куски кода, которые выполняются очень часто и такие участки кода начинают
выполняться уже не как интерпритируемые коды, а компилирует код и выполняет как бинарные операции.

	Если выходит ошибка OutMemoryError, надо смотреть чего не хватает HeapSpace или PermSpace и в зависимости от этого увеличивать память.
	