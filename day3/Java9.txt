	Строковый тип данных.
	Отличается от примитивных типов тем, что является объектом.
	
	Самый простой способ задать строку - это с помощью литералов.
	String str1 = "123123";
	String str2 = new String("rrrr");
	
	Что может пригодиться: str1.split(","); при нажатии ctr+p можно посмотреть, какие параметры принимает метод.
	str1.split(","); - вернет массив строк, разделенных запятой, но нельзя его напрямую как массив воспринимать.
	str1.charAt(0); - символ на позиции 0.
	
	Что сейчас будет?
	System.out.println(str1 == str2); // выведет false, так как это ссылки на разные объекты.
	Но есть ньюанс 
	String str1 = "123123";
	String str2 = "123123";
	System.out.println(str1 == str2); // выведет true, почему?
	Происходит интернирование. Если создаем с помощью литералов строки, компилятор будет экономить нам память, в случа если значения одинаковые.
	Поэтому нельзя сравнивать ссылочные типы через ==, надо сравнивать через метод equals str1.equals(str2);
	Но что если в str1 будет null? оператор equals умеет проверять что оператор не null
	
	Учитывать: строчки интернируются, нельзя их сравнивать через ссылки.
	Вопрос: если поменять str1, str2 изменится? Ответ: нет! Это было бы треш и содомия. Тип string изменить нельзя. Этот тип immutability.
	Как же с ними работать?
	String s = "aaaa";
	s.toUpperCase();
	System.out.println(s); выведет s в нижнем регистре.
	Все операции над строками просто вовзращают измененную строку без изменения самой строки.
	Если строчка принимается из ввода, какой она становится сразу интернированной? Ответа нет - надо будет посмотреть.
	Когда проблемы?
	"a" + "b" + "c" когда часто конкатенируем строки, строки большие и нам надо часто использовать конкатенацию, нам не подходит тип string, вместо него используем
StringBuilder sbb;
StringBuffer sbf;
	API у них простой и одинаковый.
	sbb.append() - добавить символ к примеру.
	
	Разница StringBuilder и StringBuffer.
	API у них одинаковы, зачем 2 класса? StringBuffer - потокобезопасный, все методы они синхронизированны, использовать из нескольких патоков можно нормально,
зато StringBuilder - быстрее. При одном потоке StringBuffer не сильно отличается от StringBuilder.
	Мы будем использовать StringBuilder, почему? Ответ: наш алгоритм выполняется в многопоточном режиме. Если в шажочке алгоритма мы делаем операцию атомарной,
т.е. в середине работы наш обработчик не может упасть. Наш алгоритм надо делать потокобезопасным, в приложениях все равно будем делать потокобезопасность,
а зачем нам двойная потокобезопасность?
	когда мы делаем цепочку вызовов метода - это называется ..Fluent API, Flued appenc