	Структура java - файла
	Набор *.class - файлов - это и есть java-приложение.
	Если пишем модификатор доступа public - то название класса должно быть такое же как и у файла .class
	В файле может быть несколько классов, но только у одного из них может быть модификатор public.
	В методе main не может не быть аргументов, иначе он перестанет быть точкой входа.
	Пакет java.lang импортируется автоматом, поэтому не надо указывать полностью java.lang.System.out, а можно просто System.out
	Компилировать файла .java можно так: javac <имя_файла>, при компиляции создается файл .class, содержащий байт-код программы.
	Запустить можно так: java <имя_класса> (не стоит путать с именем файла, если указать имя файла(с расширением) - ничего не получиться)
	
	В промышленной разработке важно чтобы проект успешно завершался вовремя, чтобы лучше понимался(понимаемость), чтобы был гибкий,
тестопригодность, ну а потом уже абстрактоность и т.д.
	Классы подгружаются при выполнении программы динамически, т.е. пока класс не нужен - он не подгружается.
	Прежде чем оптимизировать код, надо убедиться, что это место является узким местом программы.
	При запуске программы, если какого-то class-файла не хватает, то при запуске java-приложений выпадет исключение java.lang.ClassNotFoundException.
	
	Как управлять проектами с большой кодовой базой(десятки тысяч классов):
	1) Надо повышать понимаемость - абстрогироваться от деталей и использователь инкапсуляцию, чтобы классы в пакете были не видны.
Пакет - это еденица инкапсуляции такая же как и класс. Хотим: иерархию классов и модифицировать область видимости.
// хотим поместить класс Printer в определенный пакет, используем ключевое слово package, название не может начинаться с цифры
// Посколько с помощью пакетов мы решаем конфликты имен, делаем так, чтобы наше имя класса было уникальным
// Чтобы отобразить местоположение класса, можно использовать домены, например com.jet.
С момента введения в домен, класс называется com.jet.Printer
Чтобы класс снова стал видимим, надо создать каталоги com/jet и поместить туда Printer.class, чтобы не делать это руками
Можно использовать команду javac -d . Printer.java
После ввода в домен файлов, надо не забыть, что в файлах, в которых ранее использовался этот класс, его уже там вообще нет, надо писать
com.jet.Printer printer, если не хочется писать так каждый раз, можно сделать import

import - это импорт имён (import com.jet.Printer;)
еще можно при импорте использовать wildcard, например import com.jet.*;

					Из соображений прекрасного
					Перенесем исходники в папку src, создадим папку targer
					Компильнем Printer: javac -d ./targer ./src/Printer.java
					javac -d ../target ./Demo.java из папки src
				Чтобы не заходить в папку с исходниками, мы можем использовать ключ для javac -sourcepath для указания, где находятся исходники
javac -d target -sourcepath src src/Demo.java
				Чтобы указать java, где находятся файлы *.class, которые мы затем хотим запустить, можно указать параметром -classpath
java -classpath target Demo
java -classpath target:~ Demo
target:test - перечисления папок targer и test для nix-подобных ОС
target;test - перечисления папок targer и test для ОС Windows
				Контрольные вопросы: а может так получиться, что я криворукий индус и перепутал, что у меня в разных папках одинаковый класс
				и мы передали через перечисление папки, запустится он или нет
				Ответ: да, запустится.