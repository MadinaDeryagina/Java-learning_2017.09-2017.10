	Массивы(Arrays)
	Массив - это упорядоченный набор однотипных элементов
	public class ArraysDemo {
		public static void main(String [] args) {
			int[] array; 		// Объявление массива интов(появилась ссылка в стеке, в heap пока ничего еще не появилось)
			array = new int[5]; // В этот момент выделили память, разместили наш массив в heap
			array.lenght;
			for(int element : array) {
				Таким образом мы можем обойти элементы массива.
			}
		}
	}
	Все коллекторы в Java, заодно занимаются дефрагментацией heap-а, для ускорения индексации.
	Массив - это объект, через точку можно увидеть то, что мы можем у него вызвать, жирным цветом - это то, что мы можем вызвать непосредственно от array,
остальные функции - это унаследованные от главного класса Object.
	Массивы в Java имеют тип immutable, изменять элементы мы можем, но количество элементов в массивах нельзя, чтобы добавить элемент, нам придется копировать 
исходный и добавлять в него элементы.
	Есть функция System.arraycopy(), которая позволяет быстро копировать массивы, быстро, потому что использует нативные библиотеки.
	
	Цикл foreach будет копировать значение элемента в массиве в элемент. Если у нас в массиве ссылочные типы, тогда мы можем изменять сами объекты, посколько
foreach будет копировать ссылки на элементы в массиве в элемент element;


		Расширенная тема: инициализация массивов;
	array[0] = new Cat(0);
	array[1] = new Cat(0);
	array[2] = new Cat(0);
	array[3] = new Cat(0);
		Каждый раз чтоль так делать? Нет! Мы можем сделать по аналогии с литералами.
		int[] Array = {1,2,3,4}
		Cat[] catArray = {
			new Cat(0);
			new Cat(1);
		}
		Ньюанс:
	private static void loveAllCats(Cat [] catsToLove) {     //Можно ли сюда передать литерал?
	}
	Можно, но если мы хотим передать литерал, там надо объяснить компилятору, что мы передаем.
	loveAllCats(new Cat[] {
		new Cat(0),
		new Cat(1)
	});
	В Java компилятор при передаче массивов в функцию не может вычислить тип передаваемого параметра.
	
	Многомерные массивы.
	int[][] matrix = new int[5][];
	Создается одномерный массив, каждая ячейка которого содержит ссылку на другой одномерный массив, в котором и содержатся элементы.
	int[][] matrix = new int[5][4];
	matrix[0][1] = 0;
	Можно сделать вот так:
	int [][] literalMatrix = {
		{1,2},
		{},
		{1,2,3,4},
		null
	}
	
	int[] nullarray = null;
	nullarray.lenght; //NullPointerException
	
	
		Vararg(Логическое продолжение массивов);
	int main(String ... args) - так вводится Vararg
	С помощью Vararg можно вводить любое количество переменых, можно передавать например массив массивов.
	У Vararg есть серьезные ограничения, можно ли сочетать Vararg с другими типами? Можно, но Vararg можно только один и если мы хотим передать допустим
только int s, то его надо включать после Vararg.


		Практика: архитектура нашего логгера на 2 итерации тестов сильно изменится