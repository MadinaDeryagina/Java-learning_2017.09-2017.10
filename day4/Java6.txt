			Объектно-ориентированное программирование(ООП).
	В процедурном стиле мы пользуемся методами, стараемся минимизировать область видимости этих процедур, чтобы нельзя было как угодно изменять состояние программы.
	Процедурная генерализация: если есть схожие действия, мы можем выполнить их одной функцией, введя функцию с большим количеством параметром.
	
		Объектно-ориентированный анализ и проектирование(OOAD)
	package ooaddemo;
	
	public class Logger {
		public void log(String message) {
			if(!filter(message)) {
				save(message);
			}
		}
	}
	
	Что делать, если в функции save, нам надо использовать разные способы сохранения, например - пишем в файл, либо в базу данных, либо на консоль?
	Мы можем спрятать реализацию внутри метода save и выбирать поведения в зависимости от состояния.
	пример:
	
	private void sava(String message, flag) {
		if (flag == 1) {
			SaveToDB();
		}
	}
	Но тогда у нас получается больое количество функций, переменных и т.д. Читать такой код становится сложным. Мы сделаем по другому.
	
	
	Функцию фильтрации экстрактируем в другой класс.
	
	сделаем так:
		public class Logger {
			private LoggerFilter filter;
			private LoggerSaver saver;
			
			public void log(String message) {
				if(!filter.filter(message)) {
					saver.save(message);
				}
			}
	}
	Теперь поведения метода save зависит от saver.
	Реализация: как именно будет сохраняться и как именно будет фильтроваться - мы определим уже потом.
	Мы селали 1-ый шаг к OOAD.
	Responsibility(ответственность). Какая ответсвенность на saver - сохранение, какая ответственность на filter - фильтрация. Разнесли ответсвенность.
	Какая ответсвенность тогда получается на логгере? Логгер выступает в роли контроллера - он определяет последовательность действий.
	
	Принципы проектировани:
	1. OCP(Open Closed Principle): идея должна быть для чего-то открыта, для другого закрыта. Система должна быть закрыта для изменений, но открыта для 
дороботок. Тут приходит такаяидея: абстрагирование.

	public interface LoggerSaver {					//Это интерфейс
		public void save(String message);
	}
	Теперь надо прописать реализацию
	public class FileLoggerSaver implements LoggerSaver
	public class ConsoleLoggerSaver implements LoggerSaver
	Это позволяет полностью абстрагироваться от реализации. Эти классы являются полностью взаимозаменяемыми. Наш дизайн становится полиморфным.

	Способы дизайна: a. Начинаем с внешних уровней. Сразу думаем о том, что может меняться.
		b. Вырываем реализацию и навешиваем на нее абстракцию.(emergent design) - такой способ проще.
		В условиях неопределенности лучше делать проще, но если мы знаем, что это понадобится, лучше это сразу закладывать.
		
		Что есть дизайн с точки зрения ООП. 
	2. DIP(Dependence Indvertional Principle)
	Если нам надо повысить абстракцию, мы разрываем связь и навешиваем на нее интерфейс.
	
	Возникает проблема выбора порождения объекта. Для этого есть шаблоны программирования.
	Тут мы приходим к паттерну creator.
	Чтобы логгеру не прищлось выбирать реализацию, мы просто перекинем эту функцию на другой класс. Для этого есть паттерн, которые называется Factory.
	Чтобы снизить ответсвенность по созданию дизайна, есть паттерн, которые ответсвенен только за создание объекта.
	Фабрика может сама выбрать, как нам порадить объект на основе например параметров или конфигурационных файлов.
	Что мы получили после этого усложнения? Конечно гибкость. Еще это не очень очевидно, но мы постепенно повышаем тестопригодность, потому как мы можем
вместо определенных функций делать загрушки. 1-ое требование тестопригоности - это отсутсвие жесткой зависимости.
	Также можно изменить способ порождения - это называется Factory Method - Abstract Factory(Абстрактная фабрика) Мы можем сделать фабрику фабрик.
	Увеличение количества фабрик ведет к усложнению и в какой-то момент просто необходимо остановиться иначе возникает Registry(паттерн Реестр).
	
	Логгеру можно указать, чтобы он не пытался выбирать saver, для выбора конкретной реализации saver, мы делаем конструктор.
	private LoggerSaver saver;
	public Logger(LoggerSaver saver) {
		this.saver = saver;
	}
	Когда нужную зависимость мы ждем от внешней стороны - это называется Dependency Injection: constructor или setter;
	
	Дальше, можно же автоматом собирать приложение, тесты, все это, вставлять нужные заглушки для тестов, для этого есть Dependency Framework, например spring.
	Тут нам на помощь приходят аннотации, аннотации являются конфигурацией для таких вот фреймворков.
	@Autowired
	@Inject	
	Зачем мы сюда шли? Минимальные изменения в классе логгер, тестопригоность, гибкость, осозноваемость.
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	