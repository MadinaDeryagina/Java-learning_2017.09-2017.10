		Полиморфизм.
	Что такое полиморфизм? Это ситуация, когда мы используем объекты различных типов, адресуя их одной объектной ссылке абстрактного типа.
Единая форма - разное содержимое. Зачем оно надо? Ответ: гибкость.
	Абстрактный класс - это класс у которого есть хотябы один абстрактный метод(т.е. метод не имеет тела).
	Мы не можем создать объект абстрактного класса.
	2 способа использования: 
		1. В полиморфизме - сделать ссылочку типа абстрактного класса, тогда при объявлении ссылки будет какой-то базовый класс.
		2. Повторное использование в дочерних классах.
	Шаблонный метод: суть в том, что мы хотим повторно использовать каркас метода, т.е. в наследнике переопределяем поведение метода. В качестве альтернативы 
шаблонному методу мы использовали Контроллер(паттерн Strategy). В этом они похожи, но в стратегии мы используем делегирование, а в шаблонном методе используется
наследование.
	Кастинг типов: кастить можем не только примитивные типы. Кастить можем только вниз (от более общего типа) к более частному.
	Поэтому надо каждый раз проверять 
	if(filter instanceof MessageContentFilter) {
		((MessageContentFilter)filter)      //Кастим тип, если инстанс.
	}
	
	Интерфейсы - это абсолютно абстрактные классы(у него все методы абстрактны);
	
	public interface LoggerFilter {
		int MY_SUPERCONST = 0;
		public boolean filter(String message);
	}
	Отличие интерфейса от абстрактного класса:
		1. в том, что в интерфейсах нет полей. Все переменные в них объявляются являются статическими константами.
		2. Технология реализации: в абстрактных классах мы можем наследоваться только от одного класса, классу можно имплементировать любое количество интерфейсов.
		
	Есть интерфейс, который не заставляет реализовывать ни 1 метода - Serializable - какой-то маркерный интерфейс. Когда мы имплементируем и сообщаем
что мы готовый какие-то действия с этим делать.

	С Java 8 произошло ужасное - в интерфейсах появилась реализация методов. Зачем это так сделано? В Java 8 ждали лябды, сложно было встроить лябды в существующие
библиотеки. Лябды - это анонимные функции, т. е. типо коллекция возьми функцию и примени ее к этому элементу.
можно делать статик методы, можно экземплярные (default)

	public interface LoggerFilter {
		int MY_SUPERCONST = 0;
		public boolean filter(String message);
		
		static void m() {
			System.out.println("");
		}
		default void m2() {
		
		}
	}
	Давайте не будем делать реализацию в интерфейсах. Лучше сделать абстрактный класс.
	
	Статические методы при наследовании не овеерайдятся. При вызове статического метода от ссылки будет вызван метод того класса, к которому относится эта ссылка
	
	Полиморфные аргументы. Если нам надо передать какой-то тип(любой) - мы можем передать интерфейс и реализовать интерфейс так, чтобы он отработал в соответсвии
с ожидаемым типом.
	




		Большая практика:
	1. Заказчик хочет: объектный стиль, начать делать перепроектирование.
	2. Фасад остается - тесты трогать в идеале лучше не трогать.
	3. Сделать сэйвер и переключаться между реализациями(если хотим переключиться - это подразумевает рестарт).
	4. От нас не ждут, что мы можем независимую смену типов форматирования независимо от типа данных(Т.Е. функцию форматирования можно отдельно не выводить).
	5. Сделать сообщение как умный объект(Когда тип данных зашит + поведение для это типа). Логика аккумулятора отправляется в message.
	6. Можем ли мы сделать еще умнее, чтобы не делать контроллер - сам message должен уметь себя сохранять.(Это не обязательно, но было бы круто).
	7. Не надо делать слишком сложно, просто надо посмотреть разные варианты. Message - абстрактный метод и есть разные реализации этого message.
	8. Задание со звездочкой - сделать шифрование, сделать шаблонный метод.
