		Наследование.
	Зачем нужно наследование?
	1. Полиморфизм.
	2. Повторное использование уже существующего функционала.
	DIP(Dependency Injection principle):
	1. Вырываем класс
	2. Навешиваем на него интерфейс.
	
	protected abstract String encode(String message);
	Ключевое слово abstract - позволяет не реализовывать метод, а реализацию переложить 
в класс - расширение. Но тогда надо abstract навесить и на класс. Это называется Шаблонный метод. Наследование считается более простой реализацией, но менее гибкой.
У нас есть замечательно слово super. Чтобы реюз обеспечить

	Можем ли научить message, чтобы он сам себя редактировал в зависимости от формата. Можем.
	Можем ли мы вырвать определение формата и редактировать message на основе формата. Можем.
	Что выбирать? То что проще, если не нужно обратного.
	
	Скрытая проблема: Класс не всегда может гарантировать определенное поведение предка.
	При переопределении методов.
		В процессе оверрайдинга, нам надо переопределить поведение метода. Имея ссылочку метода сейвер - нам должно быть пофигу, какой метод выполнится.
Но есть ограничения:
	1. Должна быть точно такая же сигнатура. Методы должны быть абсолютно одинаковыми( с точки зрения как братья - близнецы ).
		save(message) в одном классе должен вызываться одинаково для всех классов.
	2. Можно ли возвращать разные типы? Пример: фильтр возвращает определяет тип, в процессе переопределения мы можем сделать точно такой же метод, но
возвращать надо либо такой же тип, либо тип, который унаследован от типа возвращаемого значения базового класса.
	3. Модификатор доступа. В процессе наследования мы не имеем право сужать область видимости. Если сузим - код сможет поломаться, если расширим, ничего плохого
скорей всего не произойдет.

	inheritancedemo
	package inheritancedemo;
	
	public class Demo {
	}
	
	class Message {
		private final int type = 1;
		public boolean isSameType(Message m) {
			return m instanceof StringMessage;
		}
	}
	
	class IntMessage {
		private final int type = 2;
	}
	
	Наследоваться можно только от одного класса. Единственное - можно делать сколько угодно интерфейсов - расширять функционал с использованием реализации нескольких
классов.

	Аннотации:
	@Ovveride. Сами по себе аннотации не исполняемы, они являются указанием для внешней среды изменить свое поведение.
	4 Базовых аннотаций.
		Все что можно сделать без аннотаций - можно делать без аннотаций. Аннотации есть не только препроцессорные.
	1. @Ovveride - типо документирование, что этот метод мы переопределяем. Но и указывает, что эту функцию мы именно override-им, а не overload-им.
	2. @Deprecated - когда какой-то кусочек кода, класс, метод поле это было ошибочное/устаревшее решение и это надо выпилить, но не нарушить функциональность.
Эта аннотация помечает функцию как подготовленную к ошибочную и подлежащую удалению. Компилятор перечеркнет такой метод.
	3. @SuppressWarnings({"unchecked"}) - это подавление разных видов warning-ов компилятора.
	4. @Autowired - позволяет автоматически создать контейнер объекта типа. Пример:
	@Autowired
	private SaveFactory saverFactory; // Autowired создаст объект.
	
	
	
	
	
	
	
	
	