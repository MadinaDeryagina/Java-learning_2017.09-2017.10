По требованиям к логгеру:
	Зачем к каждому классу еще добавлять тип. При добавлении классов, надо залезать в класс и прописывать тип.
	Если у нас enum, тут вторая проблема - мы витвимся по enumum. 
	Самый лучший способ - это сделать класс message с названием типа сообщения, например intMessage.
	
	Чем опасен reflection - такой API, через который мы можем получить любой метод и тип вне зависимости от того, какой у него модификатор доступа.
	Reflection используется для системной/низкоуровневой разработки. За рефлекшионом скрывается еще более темная магия. Ничего не зная о структуре класса,
	мы можем создать класс сами в процессе выполнения, подкинуть туда свои функции, переменные и т.д.
	Этот стиль программирования называется Метопрограммированием.
	
			Конструкторы
	Ключевое слово this используется для разрешения конфлика имен в методах и конструкторах.
	this - это указатель на эклемпляр своего класса.
	Самый простой конструктор - это получить параметры и установить поля класса.
	Конструктор - это метод класса, который вызывается при инициализации этого класса.
	Модификаторы доступа конструктора могут быть privare, public, protected, package.
	Важный момент: конструкторы можно перегружать.
	Из одного конструктора можно вызвать другой констркутор:
	public LoggerController(int a, int b) {
		this.a = a;
		this.b = b;
	}
	
	public LoggerController() {
		this(a, b); 					//Вызвали конструктор LoggerController(int a, int b)
	}
	Если не написать конструктор, компилятор напишет его сам автоматически - это конструктор по умолчанию.
	
			Проблемы с конструкторами:
	1. Конструкторы в Java не наследуются.
	2. Если они не наследуются, надо делать в классе-потомке конструктор, который будет вызывать конструктор базового класса.
Наши конструкторы обязаны вызывать конструкторы базового, до тех пор пока не вызовут главный конструктор - конструктор класса Object.
для этого есть метод super - вызов конструктора базового класса. Компилятор обяжет нас вызвать конструктор базового класса.
Также мы не можем вызвать конструктор через голову.
	3. Если мы делаем свой конструктор в классе-потомке, тогда конструктор базового класса пропадает. Вызов супер должен идти вначале, если мы в конструкторе 
дополнительно хотим изменить какие-то поля объекта - это будет гарантировать последовательный вызов конструкторов.
Вызов this и super нельзя сделать одновлеменно, можно либо один либо другой - они являются взаимоисключающими.

		Блок инициализации:
				//Экземплярный блок инициализации.
		{
			System.out.println();
		}
		Что вызовется первым? Блок инициализации или конструктор? Ответ: не то и не другое - блоки инициализации поместятся в конструкторе сразу после ключевого
слова super. Использовать блоки инициализации - это плохой тон.