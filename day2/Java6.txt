		Большая тема: синтаксис для процедурного стиля
	Посмотрим, как управлять ветвлением, посмотрим встроенные типы, также посмотрим Array и Ararg
	В git надо стараться помещать чистый код без временных комментариев.
	В java есть JavaDoc - комментариев, по которым потом можно построить документацию в формате html
	В JavaDoc можно использовать html-разметку, по нажатию @<ctrl+пробел> можно выбирать параметры, также выбирать типы. Все эти кусочки превратятся потом 
в JavaDoc - документацию. По нажатию ctrl+b на методе, можно попасть прямо в исходник и посмотреть, как он описан и закоментирован.
	Если хотим посмотреть, как в сумме эта документация будет выглядеть, надо запустить инструмент JavaDoc, можно зайти на docs.oracle.com и посмотреть
как это будет выглядеть. JavaDoc можно запустить с консоли, посмотреть ключи, он идет в комплекте к JDK. Руками javadoc запускать не придется, в maven есть
плагин, которые называется Maven-javadoc-plugin.
	JavaDoc редко используется для полей, обычно документируются методы. Для версионного описания можно использовать метку @since
	Если мы наведем курсор на метод или класс, нажмем ctrl+q или через ctrl+shift+a(там введем quik documentation), можно будет в popup 
	посмотреть/добавить документацию с подсветкой.
		Название классов, методов должно содержать буквы/цифры, не начинаться с цифры, никаких символов. Java поддерживает unicode, поэтому можно
	использовать разные языки.
		Есть такая вещь: Java Coding Style Convention.
		Стиль написания: название класса должно называться camell-case, Каждое новое слово в названии класса/метода пишется с большой буквы, остальные маленькие.
	Обычно даже если слово является абривиатурой, первая пишется заглавной, остальное lower-case.
	Если есть поле, например public static final string MY_SUPER_CONSTANT ="", то есть через _ разделяем.
	В названиях пакетов не принято использовать upper-case, поэтому если пишем, то пишем примерно так: package com.acme.edu.mysupperpackage;
	
		Чуть забежим вперед: если хочется взять и класс переместить в другой пакет, то нажимаем на класс, <ctrl+shift+a> - и делаем move(To package), 
пакет можно создать на ходу, если мы укажем ему. Перенос произойдет автоматически, <ctrl+shift+a> - также можно сделать rename, он должен переименовать пакет.
Перед переименовыванием, он посмотрит, не используется ли класс еще где-либо, если используется, он спроси - переименовать в других местах этот пакет - нажмем
да - он переименует.
		
		Модификаторы:
		public - модификатов, который позволяет использовать метод всем.
		public static void logString()
		Надо стараться задавать имя для методов таким образом, чтобы из их названия было польностью понятно, что делает этот метод.
		Статические методы - по сути это глобальные методы, в Java нельзя использовать глобальные методы, обязательно надо находиться в каком-либо классе.
Поэтому класс является просто контейнером для статического метода, но можно относиться к ним как к глобальным методам.
Вызвать функцию можно так сom.acme.edu.Logger.logString("Hello world");
Если не хотим указывать название класса перед вызовом, можно сделать import static com.acme.edu.Logger.logString;
Простой импорт отличается от static-импорта тем, что статик импорт импортирует статические методы и поля, а простой импорт просто импортирует классы.
	Есть такая вещь 
		static {
			...
		}
	Это блок статической инициализации, эта вещь отработает при загрузке класса. Класс загрузится, когда, где-то в коде всплывет ссылочка на этот класс.
	При загрузке класса, может возникнуть исключительная ситуация, тогда класс не загрузится, но можем обработать исключение и все-таки загрузить класс.
		В классе можно использовать и статические и динамические методы. Ко всему статическому мы имеем доступ через имя класса, к динамическим имеем 
доступ через имя экземпляра класса. Статические методы, лучше вызывать только через имена классов, не через объектов.
		
		public static int state; - это аналог глобальной переменной, ее можно получить от имени классов, например	
		
class test{
	public static void main(String[] args) {
		Main.globalState = 1;               		// Взяли переменную из класса Main
    }
}

class Main {
	public static int globalState = 0; 					// Это глобальная переменная, ее можно использовать везде, через имя класса, она жива, пока жив класс.
	public int instanceStat = 0;						// До этой переменной есть доступ только внутри объектов этого класса, она жив экземпляр класса.
	public static void function(int message) {
		int localState = 0;								// Эта переменная доступна только пока работает функция. По завершении функции, переменная будет уничтожена.
														// Эта переменная:
																// временная, потому что живет только во время выполнения функции
																// автоматическая, потому что удаляется автоматом, при завершении функции
																// стековая, потому что кладется в стек
																// локальная, потому что не видна вне функции(4 названия).
	}
}
	Что такое стек:
		Когда вызываем функцию, нам надо сохранить где-то локальные переменные, и адрес возврата, чтобы там оказаться на том месте, где мы бы были, если были
эта функция не вызывалась(адрес возврата).
	Сколько живет параметр функции? Параметр функции является такой же локальной переменной, как и те, что внутри функции - это называется формальным параметром.
	Примитивные типы передаются в Java по значению(Path by name).
	
	Переменные могут быть не примитивного типа, тогда мы передаем такие объекты ссылками, при передаче получается копирование ссылок. Создается вторая ссылка,
которая указывает на тот же объект. По ссылке мы можем поработать с объектом, после выхода из функции, объект будет изменен.
	Вернемся к стеку: память в стеке ограничена аппаратно(не получится больше, чем размер оперативы, но в JVM память поумолчанию ограничена 1024 байт)
Можно задать при запуске ключами количество оперативной памяти, например -Xss2m - 2 мегабайта на стек, -Xms4G - минимальное кличество памяти, -Xmx4G макс размер
Стеков может быть несколько, для каждой нити(thread) могут быть свои стеки.
	
	
				Рекурсия.
	Можно ли из метода main вызвать себя же? Можно, но произойдет глубокая рекурсия и выйдет сообщение StackOverFlowError.
	Для рекурсии обязательно должно быть условия выхода из рекурсии.
	
	
	
	
	
	
	
	
	
	
	
	
	