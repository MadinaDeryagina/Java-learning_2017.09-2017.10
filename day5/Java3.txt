		Синтаксис.
	1. final. Есть 3 разных семантики.
	Можно сделать поле класса final, локальную переменную final. Если мы говорим, что поле/переменная final - мы делаем ее константой.
Есть важный момент: если у нас ссылочный тип, это означает, что ссылку изменить нельзя, но сам объект является изменяемым. В Java константность объекта нужно
делать руками - самый простой способ сделать поля и методы private и убрать setter. В java есть ключевое слово const, но пока const не работает.
Модификатор final можно сделать для класса, это не значит, что его поля становятся константами, это означает, что от него нельзя наследоваться.
Если мы ставим final для метода - мы говорим, что его поведение в классе-наследнике нельзя переопределить. В большинстве библиотек классы являются final.
	2. Enum. Это такой тип данных, чьи переменные могут принимать только определенный тип значений.
	enum Color {
		R, G, B
	}
	Color color - Color.G; // nтеперь переменная color может принимать только одно из 3-х значений.
	Что еслиб мы хотели сделать на классах enum
	final class Color {
		private int ordinal;
		private Color() {
			this.ordinal = ordinal;
		}
		public static final Color R = new Color(1);
		public static final Color G = new Color(2);
		public static final Color B = new Color(3);
		
		//Хотим метод, который вернет, какие значения может принимать этот тип
		public static Color[] values {	
			return new Color[] {R, G, B};
		}
	}
	Получается в контейнере Color 3 переменные - поля типа Color. К ним можно обратиться и за счет final - их нельзя будет изменить.
	Таким образом классом Color мы сэмулировали enum Color {R, G, B}
	
	enum - это не объект - это структура данных, у него нет поведения. enum лучше выводить в отдельный файл
	





	