		Вопрос: у нас очень много классов, проблема - надо упростить все это. Как это упростить?
		Ответ: использовать какое то решение, которое предоставит простой интерфейс. Мы делаем еще 1 класс, чьей ответсвенностью будет скрывать эту сложность.
Этот класс будет предоставлять простой набор методов, который позволит просто использовать эти классы. Реальной реализации в нем нет, но его роль - упростить 
взаимодействие с этими функциями. Это будет специальный класс, который будет только прятать сложность.
	Мы вводим специально созданный класс, который будет порождать объекты, он называется Factory. 
	Фабрика возвращает интерфейс.
	Как фабрика будет решать, какой тип порождать? 
	1. Можно явно спросить у кого-нибудь.
	2. Можно сделать, чтобы фабрика пошла в определенный файл и порадила объект определенного типа.
	В рантайме обычно заморочек не будет 99% программ - это прикладной софт, нам не придется на ходу выгружать/загружать классы.
		
		
		Паттерн - мы вводим новые классы или перераспределяем ответсвенности между другими классами.
	Книга GoF(gang of four) - банда 4, в ней введено понятие паттерна. Все решение проблем сводится к перераспределению ответсвенности между классами.
	
	Порождающие шаблоны.
	1. Logger-у нужен Saver. Если логгеру нужен сейвер, пусть он же и порождает сейве(самая тупая - простая реализация). Такой шаблон называется Creator.
	Появляется проблема, мы тогда не можем поставить загрушку вместо saver для тестирования - придется менять.
	2. Применяем паттерн фабрику(Factory). Вводим новый класс, чья ответсвенность - это выбор, какой тип saver создать. Вопрос: можем ли мы захотеть, что нам
надо менять процесс создания - конечно можем. Мы можем разделить объект - фабрику, одна часть которой будет выбирать, как создавать, другая какого типа объект
хотим создавать. По сути у нас получается 2 фабрики. Где же предел остановки: мы гибкость получаем ценой сложности, при порождение появляется связь, и выходит,
что все становится громоздким. Приходится чем-то жертвовать, нужно ли декомпозировать или нет.
	
	Стейтом считаются только те поля, которые являются состоянием этого объекта, это примитивные типы и ссылки, которые указывают на объекты, которые хранят 
данные об объекте - это те данные, которые не являются архитектурными(бизнес данные).
	В нашем классе логгер бизнес-данными являются поступающие сообщения: данные поступили, затем они передаются в фильтр, но они нигде не хранятся. Такой дизайн 
является stateless. Но если у нас будут сохранятся данные в объектах - у нас будет statefull дизайн. Statefull дизайн сложнее, но зато можно делать очень 
красивые диалоговые системы. В Stateless дизайне нам надо каждый раз подгружать данные, поэтому приходится гонять большие количества данных - это печально.
Statefull можно сделать лучше, но их сложнее масштабировать, надо стараться делать stateless - дизайн.

		
		
		
		
		
		
		
		
		
		
		
		
		
		