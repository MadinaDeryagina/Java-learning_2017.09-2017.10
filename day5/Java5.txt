		Займеся инкапсуляцией.
	Первая Цель сделать инкапсулируемый логгер.
	Как спроектировать логгер:
		1. Тесты должны остаться как есть, т. е. их трогать нельзя - точку входа оставить как есть. То есть.
		
		|		|	|	|						-----------------
		|		|	|	|						|				|
		|_______|	|	|--------------------->	|	Logger		|
			|_______|	|						|	Facade		|
				|_______|						|_______________|
				
				
				Что должен делать логгер:
				1. Писать.
				2. Форматировать строки.
				3. Считать(Складывать числа, которые мы пподаем ему на вход.
				У заказчика надо было спросить: будут ли эти ответсвенности меняться независимо друг от друга?
			Вдруг у нас для байта будет другая реализация подсчета или другой вывод - нам придется декомпозировать эти ответсвенности.
Способы сохранения, подсчета могут независимо друг от друга меняться. Нам нужен один объем функционала, но то, как нам раскидать функционал - это зависит от нас.
Надо декомпозировать так, чтобы достигалась максимальная изменчивость. Изменчивость - это гибкость - внутренние атрибуты класса.
			Что нужно: легко можно добавлять новые источники сохранения.  Его явно нужно выделять явно.
						Вторая - нужно выделить декорирования(легко накидывать алгоритмы декорирования) вне зависимости от типа.
						Третья - Функция суммирования - ее также надо декомпозировать.
						
			Пусть будет класс сэйвер(класс с большим количеством реализаций)
				  будет класс форматирование(также может иметь множество реализацией) можно назвать его TypeAccumulator
					IntAccumulator, ByteAccumulator, StringAccumulator
				  будет класс, который будет управлять как куда и что нам делать, его можно назвать LoggerController
					У логгер контроллера будут ссылочки, смотрящие на эти объекты.
					
		
		|				|									----------------------> s(saver)
		|	Logger		| ---------------------------------|
		|	controller	|
		|_______________|	------------------------------------------------------> F(format strings)
				|
				------------------------------------------------------------------> A(Accumulator)

					Если нет тестов, то стараться надо выбирать более простой вариант Stateless, но так как у нас есть тесты, нам надо другую конфигурацию
			контроллера. Можно сделать связку через SetterInjection
		2 варианта: ConstructoInjection и SetterInjection
		Почему мы чаще выбираем ConstructoInjection? Вариант 1: до тех пор пока мы не создали объкт saver - у нас ссылка null, Вариант 2: в ряде случаев, нам надо
синхронизировать состояние Логгера и Сеттера, нам надо не забыть, что их состояния надо менять, а мы можем это забыть.

		Можем с помощью SetterInjection можно в принципе делать, но лучше с помощью ConstructoInjection.
		
		Если с saver у нас нет трудностей, у нас проблема с выносом Аккумулятора. У нас есть хитрые правила, если передаем другой тип, то меняем поведение, как
же нам это сделать? 
Вопрос переключения: 1. log(int)
						log(string)
						Мы хотим сделать свитч по типу переменной, которая нам пришла, в это свитче что мы должны написать?
					В логгере надо прикопать переменную mode, в котром хранить то, что мы журналировани в прошлый раз
					если текущий state  == mode, то вызываем аккумулятор,
					иначе(предыдущее состояние было какое-то другое), там надо значение аккумулятора передать на функцию форматирования, далее
					надо вывести значение аккумулятора и как-то сбросить состояние.
					Надо очистить аккумулятор каким-нибудь методом clear, теперь ссылку аккумулятор надо перенаправить на другой аккумулятор, в соответсвии с
					тем, какой сообщение мы получили на текущем шаге.
					Но как нам создать объект? Если мы делаем Creator, мы сталкиваемся с проблемой тестирования, т.к. огда контроллер не получится использовать
					без аккумулятор.
					Для этого мы можем использовать map, чтобы обратиться к нужному акуммулятору с нужным типом. Самый простой способ сделать поля с разными типами.
					
						Класс логгерКонтроллер
					private fnal Accumulator byteAccumulator;
					private fnal Accumulator StringAccumulator;
					private Accumulator currentAccumulator;
	
					public interface Accumulator;
					
					public Logger(Accumulator byteAccumulator, Accumulator stringAccumulator) {
						this.byteAccumulator = byteAccumulator;
						this.stringAccumulator = stringAccumulator;
					}
					В момент, когда у нас будет переключение на другой аккумулятор у нас будет currentAccumulator = intAccumulator
					
					Вопрос напоследок: ничего не напоминают switch процедурный, можно ли сделать так чтобы не переключаться между аккумуляторами.
					
					
		State - идея такая: берем кусок алгоритма, и по состоянию легко между конкретными реализациями расчета переключаемся.
		1. Шаблон называется стратегия(Strategy). У нас есть разные способы решить 1 и ту же задачу но разными реализациями.
		State - это та же самая стратегия, но по какой причине мы переключаемся между разными реализациями в зависимости от состояния.
		
		
		Можно ли сделать полиморфней, чтобы не было переключений? Есть принцип TDA(Tell dont ask). Передизайниваем нашу историю, вместо того чтобы спрашивать
какие - то данные, мы начинаем делать. Это чистое ООП. Мы что делаем: вместо того чтобы определять какой это тип, мы делаем intMessage, stringMessage, эти классы
они умные, они сами знают как себя считать, этим самым объекты сами будут знать, как себя вести в зависимости от того типа, какой им был передан.
Приходит message - класс message определяет тип и делает то, что ему нужно сделать, затем сам себя фильтрует и сам себя выводит. Тут надо ориентировать
умными параметрами. 

		Вопрос в струдию: идея того, что мы переходим от структуры к тому что сливаем данные и действия, т.е. переходим от ask в tell вызывает ли вопросы?
		Что мы сделаем? На выходных посмотреть все это, зачем мы все это делаем? У нас появились требования к тому, чтобы системы была конечным автоматом.
		Т. е. должно быть начальное состояние - должно быть конечное состояние, должен существовать пусть из начального состояния к конечному состоянию.
		
		
		Впереди выходные. Еще синтаксис надо разобрать. На выходных спокойненько сесть посмотреть, как что куда, что еще можно сделать, что мой дизайн может,
а что не может.