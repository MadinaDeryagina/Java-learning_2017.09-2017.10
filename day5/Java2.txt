		Немного по синтаксису:
	Для объявления класса используется ключевое слово class
	
	class Logger{ // так выставляется модификатор package - он не виден снаружи пакета
	}
	
	public class Logger { // Выставляем модификатор паблик - позволяем работать с этим классом в других классах.
	}
	Нам не нужно оперировать со всеми сущностями пакетов, тогда система была бы слишком сложной для работы с ней.
	
	private LoggerFilter filter = new MessageContentLoggerFilter; - модификатор private не позволит никому, кроме самого класса.
	Это нужно, чтобы нам нельзя было из других классов изменять данные, чтобы не произошло непредвиденных ситуаций.
	С целью недопущения изменения полей, мы делаем обертку для определенных типов и закрываем там возможность изменения этих полей.
	Если нам нужны изменения: сделаем setter и getter в обертке, в которой будет устанавливать поля, до которых нет прямого доступа.
	Но если нам допустим надо поменять поведение нашего класса, что же нам делать?
	Мы создаем новый класс и наследуем его от класса родителя, дальше переопределяем поведение в классе потомке. Если бы у в классе родителе мы работали
с полем напрямую, мы не смогли бы ничего поменять в классе потомке, поэтому нужно заранее делать сеттеры и геттеры - на будущее.

	Liskov Substitution Principle(LSP) - проектируем таким образом, чтобы мы могли базовый класс заменить на класс-наследника.
		Иногда нам надо вызвать функции потомков через ссылку на родительский класс, мы можем сделать явное приведение типов
	Например 
	Cat cat = new BlueCat(1);
	BlueCat cat1 = (BlueCat) cat;
	Но если мы сделаем так: 
	Cat cat = new Cat(1);
	BlueCat cat1 = (BlueCat) cat;
	У нас возникнет ClassCastException
	Можно избавиться от этого так:
		Cat cat = new Cat(1);
		if(cat instanceof BlueCat) {
			BlueCat cat1 = (BlueCat) cat;
		}
	У нас возникает проблема: мы начинаем ветвиться по типу, теряется объектность. Expression problem - как бы мне так добавить функционал без ветвлений по типу.
Для решения данной проблемы есть такой паттерн visitor.
	Что делать, если какая-то функция в родительском классе, которая отсутсвует в дочернем классе. И мы пытаемся вызвать эту функцию в дочернем классе, тогда.
Для конкретного типа придется добавить исключение при вызове этой функции.

	Что если мы хотим набор полей от базового класса, но поведение от класса-потомка, как нам это сделать? Нам придется вводить промежуточный класс, потому как
в Java у нас статичиская типизация.

	Основные тезисы:
		1. Делаем инкапсуляцию(скрываем): а) на уровне пакета для осозноваемости на уровне пакета; б) на уровне класса - обеспечиваем целостность.
в) обеспечиваем reuse.
		2. Полиморфизм - если у нас есть ссылочка на объект класса, через точку мы увидем его методы, но не увидим методы потомка.
		3. LSP - так надо проектировать реализации, чтобы при замене одной на другую - у нас ничего не ломалось(без изменения базовых классов). Все
реализации не ломают базовый тип. Что если одна реализация что-то не умеет? Ответ: лучше выкидывать Exception, чтобы хотябы об этом узнать.
		
		
		
		
		
		
		