			Exception
	Exception - ошибки в run-time. Нам надо разделить 2 ражима работы: 
		1. main-flow - штатная работа приложения.
		2. alternativa-flow - альтернативный режим.
	Зачем это нужно? Ради отказоустойчивости. Мы имплементируем системе, как она должна вести себя в такой ситуации.
	Теоретически мы можем словить все ошибки системы, но стоимость такой системы будет близки к бесконечности.
		Отказ системы - когда система отказывает в обслуживании, но это было запланировано.
		Сбой системы - когда система отказывает в обслуживании, но мы тут как бы не причем.
	
	Обработка отказов системы:
		1. Мы хотим, чтобы при ошибке у нас вышло сообщение и все продолжило выполняться.
		2. Хочется чтобы возвращалась информация об ошибке:
			a) Хотим чтобы выводилось максимум информации об ошибке. Объект какого-то типа - тип ошибки + дополнительные поля, которые будут описывать проблему.
		
		Что делает throw:
		1. Останавливает выполнение и переходит на блок обработки.
		2. Сохранит цепочку вызовов, которые привели к появлению данной ошибки.(StackTrace)
		
		Что хотим выводить пользователю, к примеру if (path == null) throw new IllegalStateException();
	Делаем: IllegalStateException("path is null!!!");
	throw попытается найти ближайший блок обработки такого типа сообщений, если у нас нет блоков обработки - exception вылетит из из функции main и 
найдет блок вне программы, тем самым завалит всю виртуальную машину.

		Как делается блок обработки.
		try {		//пробуем что-нибудь сделать
            new FileDao(null).getData();
        } catch (IllegalStateException e) {		//если не получилось, ловим исключение
            new FileDao("file.dat").getData();
        }
	Если внутри catch-блока у нас не возникает Exception, тогда мы считаем, что программа отработала успешно.
		Надо писать свои Exception-ы.
		
	try {
            new FileInputStream("");
        } catch (FileNotFoundException e) {
            throw new IllegalStateException("error while getting date");
        }
	Мы кидаем exception о том, что не смогли получить данные, но что если мы хотим увидеть детали (первоначальный exception), тогда мы делаем так:
	try {
            new FileInputStream("");
        } catch (FileNotFoundException e) {
            throw new IllegalStateException("error while getting date", e);		// передали е вместе с сообщением
        }
	Мелкие Exception-ы заворачиваем в более крупные. Чтобы лучше детализировать Exception.
	
	В stackTrace мы видим завороченные exception-ы так вот: caused by и дальше указывается более низкоуровневый exception.
	
			Делаем свои exception-ы.
		Создаем класс 
	public class DataException extends RunTimeException {
		public DataException(String message, );
	}
		
	try {
            new FileInputStream("");
        } catch (FileNotFoundException e) {
            throw new IllegalStateException("error while getting date", e);		// передали е вместе с сообщением
        } catch (DataException e) {
			
		}
		Каким образом компилятор выбирает в какой блок обработки попасть? Ответ : instanceof. Т.е. по тимпам.
	Там, где ошибка по нашей вине - там пишем свои exception-ы, там где просто стандартная ошибка, делаем просто catch (Exception e) {
	Если в 1 их catch мы попали и успешно отработали, тогда весь блок try - catch считается успешно обработанным.
	
		Если у нас была библиотечка на другом языке, как у нас тогда будет выведена ошибка? 
	Exception-ы будут транслироваться в java в зависимости от того, как эти библиотеки транслируют ошибки, если используется JNI, тогда у нас будет транслировано
сообщение об ошибке в Java, если просто код ошибки - придется печально проверять код ошибки.
	exception-ы можно запаковывать в другие throw new RunTimeException(e);
	Exception-ы всегда отрабатываются от более узкого к более широкому.
	Есть еще одна секция, называется finally - она нужна для того, чтобы отключить ресурсы, в случае если мы попали в какой-либо блок catch; например:
	try {
            new FileInputStream("");
        } catch (FileNotFoundException e) {
            throw new IllegalStateException("error while getting date", e);		// передали е вместе с сообщением
        } catch (DataException e) {
			
		} finally {
			fileDao.close();
		}
	Есть опять момент fileDao если будет null, тогда нам придется писать проверку:
		if(fileDao != null)
		{
			try {
				fileDao.close();
			} catch (Exception e) {
			}
		}
	Такая вот грустная история :(
	Единственный способ не выполнить блок finally - это убить виртуальную машину System.exit(0);
	Если у нас в блоке finally возникне исключене, тогда мы увидим только ошибку из него, потому что ошибка из блока finally перетрет ошибку, которая возникла
раньше. Это называется Suppretion.

	Как с этим бороться?
		Проверяем
		RuntimeException runtimeException = null;
		if(fileDao != null) {
			try {
				fileDao.close();
			} catch (Exception e) {
				if(runtimeException == null) {
					e.addSuppressed(runtimeException);
					throw new Exception(e);
				}
			}
		}
		
	try () { //В скобочках можно задекларировать ресурсы, тогда блок finally можно будет не писать, но у fileDao должна быть функция close
	}
	Через точку с запятой можно запилить несколько таких ресурсов. Ресурсы освобождаются в обратном порядке.
	Можно делать мультикэтс, главное чтобы один не был наследником другого - можно ловить братиков.
	
	В AutoCloseable выбрасывается более общий тип exception, а в Closeable выбрасывается более узкий тип exception.
	Если мы в интерфейсе делаем выброс Exception, мы должны выбрасывать только Exception-ы такого же типа, либо наследники, либо уже по типу. То есть нельзя
выкидывать exception-ы сверх тех, про которые знает предок.

	Serializable - возможность сохранить состояние куда - нибудь, на диск или в сеть...
	Throwable - printStackTrace, сохраняем message и причину(все это есть в этом классе)
		1. Сохранить string message.
		2. StackTrace.
		3. caused by - заворачить exception-ы можно.
	Error <- OutOfMemoryError (компилятор скорей всего уже несколько раз попытался вызвать garbage collector)
	Error <- StackOverFlow Для таких ошибок мы практически ничего не можем сделать.
	
	Exception <- RunTimeException. Если мы попытаемся выкинуть exception без обработки, компилятор не позволит это сделать.
	Надо разделять факт порождения exception и место его обработки, но тогда надо делать предупреждение для всего осталоьного, что мы обрабатываем exception.
	Это делается оператором throws, пример:
	FileDao(String path) throws Exception {
		throw new Exception(e);
	}
	В main не надо делать предупреждение о том, что может выйти exception, лучше добавить в сам main обработку (остальные try - catch делаем вложенными).
Вложенные try - catch делаем вложенными.

	ДЗ - взять логгер и обеспечить отказоустойчивость. Это не просто будет сделать, надо закодировать свою систему ошибок. На одном уровне выкидывать ошибку
на другом уровне ее обрабатывать. Разделять место появления ошибок и место ее обработки.
	
	
	
	
	
	
	
	


