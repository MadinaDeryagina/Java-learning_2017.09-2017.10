	Класс Object
	ctrl+нажимаем мышью на класс, переходим в класс, нажимаем alt+7 - видим методы этого класса слева
	функция toString для ссылочного типа он отработает так: имя класса@(hex-code) 
	Методы equals и hashcode
	1. equals - сравнивает объекты по значениям, если сравнивасть ссылочные типы, то будет что-то типо this == obj 
	Через Object.class. - можно получить всю информацию об объекте(о методах, ополях, об аннотациях).
	Например Cat.getClass(); // получить информацию о классе кот.
	Метод equals не полиморфен. Что предпочтительное рефлекшион или instanceof? В equals у нас порядок сравнения не важен, а в instanceof сравнение только в одну
сторону идет.
	
	2. Hash-code - компактное представление объекта в коротком виде.
		Вопросы: кто будет потребителем этой функции.
		а) Ваш же код и ваши же функции.
		б) Системная библиотека.
	Когда будем хранить наши объекты, наш код будет полагаться как минимум на наш метод equals, но лучше и на код hashCode
		Hash-code должен работать:
		a) Быстро - должен ускорять работу.
		б) Равномерно распределенно(не хотелось бы возникновения коллиизии, чтобы как можно меньше было объектов с одинаковым хеш-кодом).
	Джодж блок- Effective Java(книга про то как написать очень хорошую функцию hashCode).
	
	Вопрос со *: посмотреть почему именно такая реализация hashCode, зачем там число 31? Разобрать работу hashCode.
	Если 2 объекта equals, У них должен быть одинаковый hashCode, если 2 объекта не equals, желательно, чтобы у них были разные hashCode, хотя теоретически у 
них может быть одинаковый hashCode.
	Если override-им один из методов, обязательно должны override-ить и второй метод тоже.
	
	3. Клонирование: хотим получить 2 разных объекта с одинаковым значением.
		Клонирование достаточно хорошо защищено, метод клон сделан protected. Поэтому если мы из класса SystemDemo используем другой класс Cat extends Object, 
который extends Object,	Мы не сможем в классе SystemDemo использовать функцию clone, пока не сделаем override в классе Cat и увеличиваем его видимость.
	Если хотим использовать clone - его надо: 1 за-override-ить, 2 увеличить область видимости, 3. надо обрабатывать Exception
	Метод clone возвращает Object, потому нам придется делать downcast, либо в самом методе clone возвращать уже готовый тип наследника. Это появилось с 5 Java
называется возвращением ковариантным типом.
	Чтобы включить признак, необходимый для клонирования, надо включить маркерный интерфейс Cloneable, пример:
	class cat implements Cloneable {
	}
	По умолчанию в Java используется поверхностное копирование, т.е. если в объекте есть ссылочные типы - будут скопированы только ссылки, а не сами объекты, 
поэтому при override-е метода clone, придется идти по всем объектам и клонировать каждый из них.

	Вопрос со *: Посмотреть String является ли cloneable????
	
	
	В java9 появился REPL - то есть мы можем прямо запустить метод.
	
			Wrapper
	Начиная с 5 Java появился автобоксинг, т есть можно сделать так:
	Integer i = 0; //auto boxing - это тоже самое Integer i = new Integer(0);
	Также есть обратный авто анбоксить, т.е. int iii = i; - это тоже самое, что int iiii = i.intValue();
	Кроме анбоксинга есть статические методы, например: int iiii = 0; iiii.parseInt();
	Обертки такие Integer demo1 = 1;
				  Integer demo2 = 1;
				  System.out.println(demo1 == demo2);
				  Вернет true, потому как происходит интернирование, однако если 
				  Integer demo1 = 200;
				  Integer demo2 = 200;
				  System.out.println(demo1 == demo2);
				  Такое вернет false, потому как в Java есть гипотеза, что значения меньше байта встречается чаще и нет смысла создавать новые объекты, а более
				большие встречаются часто, потому создается новый объект.
	
	
	