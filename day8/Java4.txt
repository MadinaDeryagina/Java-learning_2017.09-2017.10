		Коллекции.
	2 группы: set и list. Коллекция - это хранилище данных, без отношения порядка.
	Set - уникальные элементы без отношения порядка. В чем выражено отношения порядка? В индексах. 
	В List нет произвольного доступа, есть отношение порядка, индексы.
	
	В Set удаляет по значению элемента.
	HashSet, NavigableSet и TreeSet - Частные реализации Set.
	Идея такая: нам хочется быстро работать с большим количеством объектов. Нам хочется быстро искать и быстро добавлять новые элементы.
Если будем просто хранить объекты в куче, у нас будет добавление за O(n) времени - это не прикольно.
Индексные структуры такой цели и служат - быстро приземлить на нужный элемент.

	Как устроен hashSet:
	Bucket - корзина - у нас есть набор корзинок, мы прыгаем в корзинку и уже в этой корзине проходим элементы друг за другом
	HashCode - определяет, в какую корзину мы попадем, хочется чтобы hashCode выполнялось быстро и чтобы хеш-коды были равномерно распределены.
	На самом деле все сложнее: у нас есть еще hash-функция, которая бьет корзинки на еще более мелкие, чтобы не было такого что мы для 100 объектов сделали
100 корзинок и у нас не получился поиск за O(n)
	Чтобы hash нормально работал, от нас ждется 2 функции equals и hashCode.
	
		В Java используются красно-черные сбалансированные деревья(частный случай бинарных деревьев).
	TreeSet - предпочтительное, когда у нас очень большое количество объектов.
	Чтобы заработали все древовидные истории, нужно явное отношение порядка. Т.е. нужно явно знать отношение порядка между двумя объектами.
	2 Способа:
		1. Интерфейс compareable. Comparator более предпочтительное, чем compareable, потому что Comparator отделяет сравнение от самих объектов.
		2. Comparator.
		Если не будет ни интерфейста compareable, ни Comparator, тогда наш TreeSet выдаст exception при сравнении.
	TreeSet - сложность O(log(n));
	LinkedHashSet - как hashSet, только элементы связываются дополнительным связным списком. Мы можем сохранить отношение того порядка, в котором мы их положили.

		Списки.
	1. ArrayList - сделан тупо на Java - массиве. Массив всегда делается с запасом в 1.5. Индексация в ArrayList очень быстрая, но где мы просаживаемся? Когда
делаем resize массива. И чем больше копируем массив, тем дольше это делается. Практически все операции модификации, кроме добавление в хвост - очень дорогие.
	2. LinkedList - двунаправленный связный список(это значит, что мы можем получить любой элемент, пойдя в любом направлении по списку) Поиск элемент делается за
O(n/2);
		RandomAccess - маркерная метка. Зачем он нужен? Collections.sort(); - модифицированный quickSort(); В зависимости от того, какой тип
ArrayList сортируется, метод quickSort модифицируется для еще более быстрой сортировки. RandomAccess нужне для того чтобы алгоритм сортировки менял свое поведение.

	Map - не коллекции. 
	1. HashMap - HashSet сделан на основе HashMap(HashSet - это HashMap, где только ключи)
	2. TreeMap - TreeSet сделан на основе TreeMap (TreeSet - это TreeMap, где только ключи)
	
	HashTable <- Properties			Эти признаны устаревшими.
	Vector <-	Stack
	В чем прикол старых коллекций? Они синхронизированны! Мы ими практически не будем пользоваться, потому что будем следить сами за этим.
		Если уж так случилось, что нам надо сделать синхронизированный вызов делаем Collections.synchronizedCollections(???); и передаем на него нашу коллекцию.
Он нам вернет обертку.

	PriorityQueue
	Dequeue - double end queue - можем в обе стороны запихивать и вытаскивать.
	
	Есть еще ряд специфичных коллекция, которые лежат в Java.util.concurent - про то чтобы выжать максимум из коллекций в распределенном режиме.
Обычно делаем с колекциями операции в монопольном доступе, но если нам надо параллельно? У одного и того же листа можно выполнять методы параллельно, 
так чтобы ничего не разрушать. Т.е. позволяют максимально эффективно работать в многопоточной среде.

	Наша задача: сколько времени мы будем программировать? Правильный ответ: 15%. Все остальное время, мы будем: а) Выяснять доп требования у заказчика;
б) Залесть в JavaDoc - посмотреть чем мы платим(памятью/производительностью) посмотреть, и сделать так, чтобы каждое наше решение было обоснованным.

	Еще пригодится  collections.unmodifiableMap();
					foreach: for(collections.iterator()); - Мы имеем быстро падающий итератор, это значит, что итератор будет смотреть, а коллекция не модифицировалась
ли, если да, то он выкинет Exception - ConcurrentModificationException. Решается в лобешник - монопольный доступ или используем библиотеку concurrent

	Последний треш - set содержит одинаковых котиков, но такой код
	public class CollectionDemo {
    public static void main(String[] args) {
        Set<Cat> cats = new HashSet<>();
        Cat murik = new Cat("Miruk");
        cats.add(murik);
        murik.setName("Murzik");
        cats.add(new Cat("Mirzik"));
        cats.forEach(System.out::println);
    }
}

class Cat {
    private String name;

    public Cat(String name) {
        this.name = name;
    }
    public void setName (String name) {
        this.name = name;
    }
}

	Выведет 2 раза Мурзик, а это нарушит инвариант set, поэтому надо делать рехэшинг

	










	
	
	
	
	
	
	
	
	
	