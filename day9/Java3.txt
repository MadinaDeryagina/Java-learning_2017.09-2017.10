		Многопоточность.
	1. Parallelism - как распараллелить мой алгоритм?
	2. Concurency - окей я распаралелен, но как мне обеспечить в паралельном окружении так, чтобы мы не нарушили наши ресурсы.
	
		Как сделать многопоточность?
	У нас ядер физических, допустим 4, есть 144 потока. Корпоративная многопоточность: каждый поток немного повыполнялся - дает другим потокам поисполнятся.
Сейчас почти везде вытесняющая многопоточность. У нас есть планировщик внутри JVM, но этот планировщик активно взаимодействует с планировщиком в ОС.
Мы можем каждый наш тред првератить в тред операционной системы, либо сэмулировать несколько тредов внутри одной нитки внутри JVM.
Нам нужен API для запуска тредов. В Java нитки достаточно ресурсоемкие. Поэтому переключение контекста процессов является очень дорогой операцией.

	Десятки тысяч тредов очень значительно могут ухудшить производительность, поэтому что мы будем делать?
		1. Делать меньше JAVA-нитей, контролиловать количество тредов, в идеале количество тредов должна быть равна количеству ядер. Плавный переход к асинхронной
неблокирующей модели.
		Thread - с одной стороны это пульт управления, а с другой стороны это действия, которые должны быть выполнены
public class ThreadDemo {
    public static void main(String[] args) {
        //Parallelism
        Thread remote = new Thread() {
            @Override
            public void run () {
                while(true) {
                    System.out.println("thread");
                }
            }
        };
        remote.start();
        while (true) {
            System.out.println("main");
        }
        //Concurrency
    }
}

		Так он начнет переключаться между двумя thread-ами, и выводить в консоль то main, то thread
	Что же можно сделать с помощью нашего пульта remote?
		У нас main - контролирующий thread, есть метод remote.stop, управление одной нитью из другой нити - это уже мертвая история, все реальное
управление должно производится в той бизнес логике, которая потенциально выполняется параллельно.
		Что еще умеет пульт управления? 
		remote.suspend, remote,resume. Если мы замораживаем поток, то засада в том, что если мы находились в секции синхронизации, то мы не дадим другим потокам
в нее войти - возникает deadlock, что еще можем?
		remote.serDaemon(true); JVM живет до тех пор, пока жив хотябы один thread не демон, это значит, что на судьбу демонов всем наплевать, если JVM
завершится - они тоже завершатся.
		remote.setPriority(Thread.MAX_PRIORITY);
			Есть 2 треда, одному приоритет поставили MAX_PRIORITY, другому MIN_PRIORITY, однакто там зависимость нелинейная, максимальный приоритет даст максимум
	25% дополнительного времени треду с максимальным приоритетом.
			Если метод stop deprecated, как нам тогда останавливать поток? Идея такая, что мы не будем насильно его прибивать. Мы должны просто напросто
	установить флажочек с просьбой остановиться и в самом процессе мы будет проверять и принимать решение - хотим ли мы останавливаться.
		Это называется remote.interrupt();
		
public class ThreadDemo {
    public static void main(String[] args) {
        //Parallelism
        Thread remote = new Thread() {
            @Override
            public void run () {
                while(!Thread.interrupted()) {
                    System.out.println("1111");
                }
            }
        };
        remote.start();
        remote.interrupt();
        while (true) {
            System.out.println("2222");
        }

        //Concurrency
    }
}

Ниточка remote - сбросит флаг interrupt статическим методом но только в той нити, в которой идет ее выполнение.
Thread.interrupted();               
Thread.currentThread().getName(); //Эти методы статические, но они получат информацию ровно о той нити из которой они вызваны.


	Очень важный момент, который нам пригодится: появляется неприятность - блокирующее состояние.
		Мы можем взять и заморозить наш поток - делается это разными методами, наприме Thread.sleep(5_000);
			или например myObject.someOperation(); //wait
			Если мы используем sleep или wait, но при этом из другого потока делаем interrupt, то нам нужен механизм, который прерывает sleep, чтобы мы могли 
проверить флажочек. Засыпание означает, что нитка заморожена. Тогда при попытке прервать сонный процесс, у нас выйдет InterruptedException, который выкинет наз
из сна и мы уже после выхода из сна проверяем, надо ли нам было выходить или нет.
		
		
		Второй способ создания потока
	Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                
            }
        });
        t2.start();
	Но в такой модели у нас возникает проблема с количеством порождения нитей. Потому нам надо зарание сделать идею пула тредов, чтобы лишний раз не создавать
и не удалять объекты - обеспечиваем  reuse уже существующих объектов. Для этого есть:
	ExecutorService pool = Executors.newCachedThreadPool();
	Но хочется контролировать их количество:
	ExecutorService pool = Executors.newFixedThreadPool(5); // создаст пул из 5 тредов.
		Технически пул представляет собой 5 тредов всегда готовых, которые образуют очередь.
	ExecutorService pool = Executors.newFixedThreadPool(5);
    pool.submit(() -> {
        System.out.println("Hello");
    }); 
	Нет гарантий, что сразу нам надо все этьо выполнить, нет гарантий, что одновременно они будут выполнены, но оно у нас точно выполнится.
	
	После того как у нас лябда выполнилась, потоки останутся висеть как активные объекты, JVM не остановится, пока мы не завершим эти объекты, тогда у нас
есть pool.shutdown и pool.shutdownNow, pool.shutdown - дождется пока завершится вся очередь, pool.shutdownNow - принудительно завершится, не дождавшись окончания
очереди.
	Что если нам надо получать результат?
	pool.submit(new Callable<Integer>() {
           @Override
           public Integer call () throws Exception {
               return 2+2;
           } 
        });
	Для получения результата у нас есть Future в JAVA
	 Future<Integer> futureResult = pool.submit(new Callable<Integer>() {
           @Override
           public Integer call () throws Exception {
               return 2+2;
           }
        });
	Есть синхронный и асинхронный методы.
		Есть второй способ получить
	futureResult.isDone(); //если получили isDone, вызываем метод get
    futureResult.get();
	В функции isDone - спрашиваем поток "ну че ты там, доделал?" если доделал, можем получить результат с помощью функции get
	
	Когда хотим получить, результат у нас могут быть сразу 2 exception-а, поэтому нам придется их обработать
	try {
            futureResult.get();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
	Последний штришочек - превращаем callable в лябду.
	
	
	
	
	
	
	
	
	